# --- Domain details ---
# x, y, z domain sizes in km
main.domain_size = 6144e+3 6144e+3 1.0e+3

# 8km base resolution -> 6144/8 = 768 x 768 grid, with 24 vertical layers
amr.num_cells = 768 768 24

# No wrap around boundaries in any direction
amr.is_periodic = 0 0 0   # 0 - not periodic, 1 - periodic

# sigma coordinate system for vertical layers in ice.
# 0 - surface, 1 - base
# higher resolution near the base where velocity gradient is steep
amr.sigma = 0.0 0.0712603   0.14191442  0.21137662  0.27910062  0.3445959
  0.40744022  0.46728806  0.52387456  0.5770154   0.62660312  0.67260068
  0.71503302  0.75397751  0.78955403  0.82191523  0.85123747  0.87771266
  0.90154127  0.92292652  0.94206966  0.95916636  0.97440401  0.98795991
  1. 

# BISICLES velocity comes in two components, a base velocity with du/dz = 0
# and an additional velocity which is depth-dependant.
# We turn this off for the inverse problem to save computation
amr.additional_velocity = false   # false - inversion, true - forward problem


# --- Bulk constitutive relation ---
# Glen's law with L1L2 constitutive relation and Arrhenius rate factor

main.constitutiveRelation = L1L2
L1L2.n = @n   # Glen's law exponent

# During effective viscosity solve, coarsen vertical layers by factor of 2^k
# when L1L2.layerCoarsening = k
L1L2.layerCoarsening = 1  # coarsen by factor of 2

# Limit steep slopes during viscosity solve for numerical stability.
L1L2.effectiveViscositySIAGradSLimit = 1.0e-3   # 1m vertical per 1km horizontal

# Rate factor calculated using Arrhenius law
main.rateFactor = patersonRate  # Cuffey and Paterson (2010)
patersonRate.epsSqr0 = 1.0e-12  # small epsilon added to strain rate to avoid 
# division by zero -> infinite viscosity

# When perturbing Glen's exponent, we set a reference stress T_ref at which strain is
# equal for all n. This gives us A(n) = A(n=3)·τ^(3-n).
# Therefore add a prefactor to A, A0_multiplier = τ^(3-n)
# For these experiments, we choose τ = 100,000 kPa
patersonRate.A0_multiplier = @A0_multiplier


# --- Input data ---
# Read in initial geometry, friction, and temperature data

# Geometry
geometry.problem_type = LevelData
inputLevelData.geometryFile = /work/n02/shared/jonnieb/data/BedMachine_antarctica_v3_bisicles_1km.2d.hdf5
inputLevelData.thicknessName = thickness
inputLevelData.topographyName = bed

# Friction
geometry.beta_type = LevelData
inputLevelData.frictionFile = /work/n02/shared/jonnieb/data/matts_inversion_inputs.2d.hdf5
inputLevelData.frictionName = btrc

# Temperature
temperature.type = LevelData
inputLevelData.readInternalEnergy = true  # read internal energy instead of temperature
inputLevelData.internalEnergyFile = /work/n02/shared/jonnieb/data/antarctica-bisicles-CTplusLW_8km.2d.hdf5
inputLevelData.internalEnergyName = internalEnergy0000


# --- Basal friction ---
# Linear sliding law for inverse problem
main.basalFrictionRelation = powerLaw
BasalFrictionPowerLaw.m = 1.0


# --- Physical constants ---
constants.ice_density = 917.0  # kg/m^3
constants.sea_water_density = 1027.0  # kg/m^3


# --- Surface mass balance ---
# Constant SMB derived from MAR 1980-2021 mean
surfaceFlux.type = LevelData
surfaceFlux.n = 1  # single time slice
surfaceFlux.timeStep = 1.0e+10  # huge time step, i.e. no time dependence
surfaceFlux.startTime = 0.0
surfaceFlux.fileFormat = /work/n02/shared/jonnieb/data/antarctica.mon-SMB-MAR_ERA5-1980-2021.mean.smb.hdf5
surfaceFlux.name = SMB


# --- Basal mass balance ---
basalFlux.type = maskedFlux
# Zero basal flux during inversion
basalFlux.grounded.type = constantFlux
basalFlux.grounded.flux_value = 0.0
basalFlux.floating.type = constantFlux
basalFlux.floating.flux_value = 0.0

# During the initialisation, we hold the ice shelves steady by adding a basal mass
# balance term, bmb = div(u·H) - smb, resulting in dH/dt = 0.
amr.floating_ice_stable = true

# Can also hold the grounding line steady in a similar way. When ice grounded below
# sea level drops below the floatation thickness, add an additional smb term which
# fixes the grounding line position.

# However, in my experience, this can lead to crashing some runs and, for various
# other reasons, we've disabled it for now.
#amr.grounding_line_stable = true

# --- Calving ---
# Prevent ice shelf advance by setting ice thickness to 0 in open ocean.
CalvingModel.type = FixedFrontCalvingModel
CalvingModel.min_thickness = 0.0  # Still allows retreat


# --- Numerics ---
# Mostly standard settings, although I have bumped up the number of Picard iterations
# since it seems to performs better than JFNK for whole-continent problems.

# velocity solve type -- 0 = Picard, 1 = JFNK
amr.velocity_solver_type = 1

# initial guess 
amr.do_initial_velocity_guess = 1
amr.do_initial_velocity_solve = 1
amr.initial_velocity_guess_type = 1 # linear PDE
amr.initial_velocity_guess_const_mu = 2.9e+6
amr.initial_velocity_guess_solver_type = 1 # JFNK

# JFNK parameters
JFNKSolver.vtopSafety = 0.95
JFNKSolver.minPicardIterations = 100  # Picard performing better than JFNK
JFNKSolver.maxIter = 12
JFNKSolver.absTol = 1.0
JFNKSolver.relTol = 1.0e-3
JFNKSolver.solverType = 0 # Relax solver
JFNKSolver.solverType = 4 # PETSC
JFNKSolver.RelaxRelTol = 1.0e-3
JFNKSolver.RelaxHang = 0.95
JFNKSolver.maxRelaxIter = 20
JFNKSolver.normType = 2
JFNKSolver.verbosity = 5
JFNKSolver.vtopRelaxTol = 0.005
JFNKSolver.vtopRelaxMinIter = 8
JFNKSolver.numMGSmooth = 8
JFNKSolver.numMGIter = 1
JFNKSolver.h = 0.025
JFNKSolver.switchRate = 1.3

# Additional artificial drag term ~ |coef·u|^power.
JFNKSolver.artificialDragCoef = 1.0e-4 # velocities over 10kma^-1 suppressed
JFNKSolver.artificialDragPower = 8

# Limit driving stress in areas with steep slopes to avoid numerical instabilities.
velocity_rhs.max_rhs_dx = 1.0e+9 # roughly corresponds to 100m ice cliff


# --- Eliminate remote ice ---
# Searches for connecting "bridges" of ice between cells. Any ice only connected to 
# the ice sheet by bridges below a certain thickness is removed.
amr.eliminate_remote_ice = true
amr.eliminate_remote_ice_max_iter = 16
amr.eliminate_remote_ice_tol = 2.0  # min thickness for ice to be considered connected
amr.eliminate_remote_ice_after_regrid = true


# --- Time stepping ---
main.maxTime = 0  # increment this in job script
main.maxStep = 100000  # terminate run if this many timesteps are reached
amr.temporal_accuracy = 1
# cfl - Courant-Friedrichs-Lewy condition
amr.cfl = 0.25  # timestep is 0.25 * dt_max where dt_max is determined by CFL
amr.initial_cfl = 0.25  
amr.max_dt_grow_factor = 2.0
amr.time_step_ticks = 0  # if 1, use 'nice' timesteps, e.g. 1/8, 1/4, 1/2, 1, etc.


# --- Plotting ---
amr.plot_time_interval = 0.2  # save a plotfile every 0.2 years
amr.plot_prefix = plot/plot.lasagne.@name.3lev


# --- Checkpoints ---
amr.check_interval = 32  # save a checkpoint every 32 timesteps
amr.check_prefix = chk/chk.lasagne.@name.3lev
amr.check_overwrite = 0  # 1 - overwrite existing checkpoint, 0 - don't overwrite


# --- AMR mesh options ---
amr.maxLevel = 10 # max levels of refinement
amr.ref_ratio = 2 2 2 2 2 2 2 2 2 2 2
amr.tagCap = 2 # Finest level that can be tagged for refinement
# Therefore 3 levels of refinement total, 8000->4000->2000->1000 m

amr.regrid_interval = 4000  # very large – don't bother regridding during inversion
amr.blockFactor = 16      	# block factor used in grid generation
amr.fill_ratio = 0.85    	  # how efficient are the grids
amr.nestingRadius = 1    	  # proper nesting radius required
amr.tags_grow = 4        	  # pad tagged regions with this many cells
amr.interpolate_zb = 0 		  # don't go back to the IBC to regrid geometry
amr.max_box_size = 32       # largest box length allowed


# --- AMR tagging ---
# Tag regions of the ice sheet for refinement based on grounding line proximity
# and absolute velocity (not velocity gradient).
amr.tag_on_grad_velocity = 0  # don't tag based on velocity gradients

amr.tag_grounding_line = 1    # tag based on proximity to grounding line
amr.grounding_line_tagging_min_vel = 20.0  # min velocity for tagging
amr.grounding_line_proximity_calc_type = 1 # 0 - linear, 1 - quadratic

amr.tag_vel_dx = 1  # tag when velocity * dx exceeds threshold
amr.vel_dx_tagging_val = 5.0e+5  # threshold
# dx = 8km -> threshold = 62.5 m/a
# dx = 4km -> threshold = 125 m/a
# dx = 2km -> threshold = 250 m/a
# Can also set different tagging limits for grounded and floating ice.
amr.vel_dx_finest_level_grounded = 3  # default -1 (no refinement)
amr.vel_dx_finest_level_floating = 3  # default -1 (no refinement)

amr.tag_thin_cavity = true # tag thin submarine cavities in attempt to refine pinning points
amr.tag_thin_cavity_thickness = 50.0

# --- Misc options ---
amr.verbosity = 5


# --- Inversion options ---
# "Lasagne" inversion: alternate between inverse problems and short periods of
# relaxation. 

# This approach is designed to combat the "chicken and egg" problem with bed friction 
# inversions. Historically, inversions are carried out followed by a subsequent
# relaxation. However, during this relaxation, velocities can evolve such that they
# no longer match with observations.

# The hope with lasagne inversions is that we see the inverse and relaxation converge 
# alongside each other towards a quasi-steady initial state that closely matches
# observations of ice velocity.

amr.velocity_solver_type = 6 		  # Inverse problem
amr.velocity_solve_interval = 1 	# Solve velocity every timestep
amr.evolve_thickness = true			  # Lasagne inversion


control.velMisfitType = speed 				    # Match observed speed (not velocities)
control.minTimeBetweenOptimizations = 1		# Time in years between inverse problems
control.minLevelForOptimization = 3			  # Solve inverse problem after refinement

control.outerStepFileNameBase = ctrl/ctrl.lasagne.@name.
control.dtTypical = 1  # save ctrl files every 1 year of relaxation

# Field of data expressing confidence in speed observations.
# linear scale between 1 - total confidence, 0.975 - high confidence
# Anything below 0.975 is treated as 0.
control.velCoef.type = LevelData
control.velCoef.fileFormat = /work/n02/shared/jonnieb/data/MEaSUREs_antarctica_v2_bisicles_1km.2d.hdf5
control.velCoef.name = notnull
control.velCoef.n = 1 # single time slice
control.velCoef.timeStep = 1.0e+10  # huge time step, i.e. no time dependence
control.thicknessThreshold = 10.0   # confidence is 0 for ice thinner than this

# xVel used for speed observations when control.velMisfitType = speed
control.xVel.type = LevelData
control.xVel.fileFormat = /work/n02/shared/jonnieb/data/MEaSUREs_antarctica_v2_bisicles_1km.2d.hdf5
control.xVel.name = speed
control.xVel.n = 1
control.xVel.timeStep = 1.0e+10

# Tikhonov regularization coefficients
control.gradCsqRegularization = 10
control.gradMuCoefsqRegularization = @aPhi

# Set bounds on initial guesses for C and muCoef - imposed at the start of each
# inverse problem.
control.initialLowerC = 1
control.initialUpperC = 1.0e+5
control.initialLowerMuCoef = 0.05
control.initialUpperMuCoef = 1.01

# Box constraints for C and muCoef during each inversion.
# C0·exp(-1.0) < C < C0·exp(1.0)
# muCoef0·exp(-1.0) < muCoef < muCoef0·exp(0.025)
# Where C0, muCoef0 are the initial values of C and muCoef in each cell
# N.B. prevent unphysical values of muCoef >> 1.0
control.boundMethod = Projection
control.lowerX0 = -1.0
control.upperX0 = 1.0
control.lowerX1 = -1.0
control.upperX1 = 0.025

# Conjugate Gradient descent algorithm has 'inner' and 'outer' steps.
# - inner steps: line search method to find optimum step size for outer step
# - outer steps: take step along loss surface down steepest gradient
control.writeInnerSteps = false
control.CGlineSearchMethod = 20   	# 0 - secant, 1 - bisection, 20 - new secant
control.CGsecantMaxIter = 8	    	# max secant (inner) iterations per CG iteration
control.CGsecantParameter = 1.0e-7

# Termination condition
# Allows for quite a bit of up and down in the loss surface, but not too much.
control.CGmaxIter = 32	  	# max CG (outer) iterations per inverse problem
control.CGhang = 5			# terminate when ||fm(x)||^2/||fm_old(x)||^2 > CGhang
control.CGtol = 1e-10		# terminate when ||f'(x)||^2 < CGtol^2 * ||f'(x)||^2_init
# CGtol extremely low -> nearly always reach max iterations.
